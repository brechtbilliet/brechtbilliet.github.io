I"≠…<p>This article is all about the do‚Äôs and don‚Äôts when it comes to writing reactive applications with <a href="http://reactivex.io/">RxJS</a> in <a href="https://angular.io/">Angular</a> applications. 
The best practices described in this article are based on personal experiences and can be assumed as personal opinions.</p>

<p>The topics we will tackle in this article are:</p>
<ul>
  <li><a href="#learning-how-to-think-reactive">Learning how to think reactive</a></li>
  <li><a href="#pipeable-operators">Pipeable operators</a></li>
  <li><a href="#ascii-marble-diagrams">ASCII marble diagrams</a></li>
  <li><a href="#using-pure-functions">Using pure functions</a></li>
  <li><a href="#avoiding-memory-leaks">Avoiding memory leaks</a></li>
  <li><a href="#avoiding-nested-subscribes">Avoiding nested subscribes</a></li>
  <li><a href="#avoiding-manual-subscribes-in-Angular">Avoiding manual subscribes in Angular</a></li>
  <li><a href="#dont-pass-streams-to-components-directly">Don‚Äôt pass streams to components directly</a></li>
  <li><a href="#dont-pass-streams-to-services">Don‚Äôt pass streams to services</a></li>
  <li><a href="#sharing-subscriptions">Sharing subscriptions</a></li>
  <li><a href="#when-to-use-Subjects">When to use Subjects</a></li>
  <li><a href="#cleancode-practices">Clean-code practices</a></li>
  <li><a href="#Angular-embraces-RxJS">Angular embraces RxJS</a></li>
</ul>

<p><strong>Note:</strong>
We will refer to observables as streams in this article.
Since the streams in this article use the <code class="language-plaintext highlighter-rouge">$</code>-suffix, a short explanation.
First of all, there is a lot of debate about the <code class="language-plaintext highlighter-rouge">$</code>-suffix but I believe this should be a personal preference. 
The reason why I prefer to use it, is because I find it very easy to separate streams from regular objects.
That being said, I would not consider it a best practice, just a personal choice.</p>

<h2 id="learning-how-to-think-reactive">Learning how to think reactive</h2>

<p>Reactive programming is completely different than imperative programming. It requires us to make a certain mind switch.
This mind switch is rather important if we want to benefit from RxJS completely.
We want to <strong>stop thinking in specific actions</strong> and we want to <strong>start thinking in streams</strong>. 
It requires us to forget a part of practices that we already know (at least for a moment).
In <a href="http://blog.brecht.io/Creating-reactive-calendar-in-angular4/">this article</a> we can find some tips and practical examples on how to start thinking reactive in RxJS.</p>

<h2 id="pipeable-operators">Pipeable operators</h2>

<p>The first best practice is the use of pipeable operators. The operators being used in this article are pipeable.
Since version 5.5 RxJS has introduced these so called pipeable operators which are easier to import than patch operators, and
also have <a href="https://webpack.js.org/guides/tree-shaking/">treeshaking</a> advantages. More information about pipeable operators can be found <a href="https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3">here</a> and <a href="https://blog.hackages.io/rxjs-5-5-piping-all-the-things-9d469d1b3f44">here</a>.</p>

<p>This example illustrates the difference between doing it the old way and the new way.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// BAD: This is the old way and should be avoided (patch operators)</span>
<span class="c1">// as we can see the operators (filter, map) are part of the</span>
<span class="c1">// Observable prototype</span>
<span class="k">import</span> <span class="dl">'</span><span class="s1">rxjs/add/operator/filter</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="dl">'</span><span class="s1">rxjs/add/operator/map</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="k">new</span><span class="nx">$</span> <span class="o">=</span> <span class="nx">Observable</span><span class="p">.</span><span class="nx">interval$</span>
    <span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

<span class="c1">// GOOD: This is the new and improved way (lettable operators)</span>
<span class="c1">// we just use the pipe operator where we pass operators that</span>
<span class="c1">// we can import from 'rxjs/operators'</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">filter</span><span class="p">,</span> <span class="nx">map</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">rxjs/operators</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="k">new</span><span class="nx">$</span> <span class="o">=</span> <span class="nx">interval$</span>
    <span class="p">.</span><span class="nf">pipe</span><span class="p">(</span>
        <span class="nf">filter</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">),</span>
        <span class="nf">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span> <span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span>
</code></pre></div></div>

<h2 id="ascii-marble-diagrams">ASCII marble diagrams</h2>

<p>Some developers tend to say: ‚ÄúGreat code should be self-explanatory, writing documentation is something that we might want to avoid.‚Äù
In some cases I would agree with that statement, but for complex RxJS code we might want to reconsider.
Streams can become complex in the following scenarios:</p>
<ul>
  <li>When we take the lifecycle of streams into account, (how long do they live? when do they start living? what destroys them?)</li>
  <li>When we start combining streams (every stream has a different lifecycle remember?)</li>
  <li>When we subscribe multiple times or even subscribe after a while, or even never subscribe to them</li>
</ul>

<p><a href="http://rxmarbles.com/">marble diagrams</a> are a cool way of visualising streams but it‚Äôs hard to put those marble-diagrams in our code right?!
There is an ASCII variant of these marble-diagrams that we can use to describe and document our complex streams and how they interact with each other.</p>

<p>ASCII diagrams have more advantages then just documenting:</p>
<ul>
  <li>It gives us a graphic thinking model</li>
  <li>It becomes easy to review someones code and validate to see if it really does what it‚Äôs supposed to be doing</li>
  <li>Great to draw on a whiteboard before we start coding</li>
  <li>You can type them in your IDE or editor before you actually start coding. (An easy way to trick your mind into thinking reactively)</li>
  <li>We can use them to write unit tests as well: <a href="http://blog.kwintenp.com/how-to-setup-marble-testing/">Checkout this awesome article</a></li>
</ul>

<p>The concepts behind ASCII marble documentation are quite simple. Take this easy example for instance:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ---a--b--c--d---e---...</span>
<span class="c1">// ---a--b--c--d---e|</span>
<span class="c1">// ---a--b--c--d---e#</span>
<span class="c1">// ---a--b-^-c--d---e</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">-</code> (stands for a time frame)</li>
  <li><code class="language-plaintext highlighter-rouge">a-z</code> (are the values that are next‚Äôed in the stream)</li>
  <li><code class="language-plaintext highlighter-rouge">|</code> (indicates that the stream has completed)</li>
  <li><code class="language-plaintext highlighter-rouge">...</code> (indicates that the stream will keep on living)</li>
  <li><code class="language-plaintext highlighter-rouge">#</code> (indicates that an error occurred)</li>
  <li><code class="language-plaintext highlighter-rouge">^</code> (indicates where we start subscribing (only for hot streams)</li>
</ul>

<p>Perhaps it‚Äôs time to check a real example and how we might document it:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">interval$</span> <span class="o">=</span> <span class="nf">interval</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>            <span class="c1">// 0--1--2--3--4--5--6...</span>
<span class="kd">const</span> <span class="k">new</span><span class="nx">$</span> <span class="o">=</span> <span class="nx">interval$</span>
    <span class="p">.</span><span class="nf">pipe</span><span class="p">(</span>
        <span class="nf">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>                            <span class="c1">// ---1--2--3--4--5--6...</span>
        <span class="nf">take</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>                            <span class="c1">// ---1--2--3--4--5|</span>
        <span class="nf">filter</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">),</span>           <span class="c1">// ------2-----4---|</span>
        <span class="nf">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>                     <span class="c1">// ------3-----5---|</span>
    <span class="p">)</span>
</code></pre></div></div>

<p>Take a minute to let this sink into your brain, because this might be <strong>THE WAY</strong> of making a complex code snippets readable for anyone.
When we take a look at this diagram, it‚Äôs fairly easy to comprehend what happens, and how every operator affects the <code class="language-plaintext highlighter-rouge">new$</code> stream we can see above. There is no ‚Äúone way of doing things‚Äù when it comes to writing ASCII marble-diagrams. You can put them where and how you want.
As we want to do for all other documentation: <strong>keep it up to date!</strong></p>

<h2 id="using-pure-functions">Using pure functions</h2>

<p>RxJS follows the concepts of functional reactive programming which basically means that we will use <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">pure functions</a> to create our reactive flow.
A function is pure when:</p>
<ul>
  <li>It doesn‚Äôt mutate anything</li>
  <li>It will always return the same value based on the same parameters</li>
  <li>It doesn‚Äôt have any side effects. It can‚Äôt mutate state outside of the function</li>
</ul>

<p>In the beginning it might seem pragmatic to use side effects, but that mostly means we aren‚Äôt fully thinking reactively. 
Therefore avoid side effects at much as possible.</p>

<h2 id="avoiding-memory-leaks">Avoiding memory leaks</h2>

<p>To consume a stream we need to <strong>subscribe</strong> to that stream. When we subscribe to that stream a <strong>subscription</strong> will be created.
That subscription will keep on living until the stream is <strong>completed</strong> or until we <strong>unsubscribe manually</strong> from that stream.
Managing subscriptions is very important and in a number of cases we will have to manually unsubscribe an existing subscription to avoid memory leaks. Take this example for instance:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">AppComponent</span> <span class="k">implements</span> <span class="nx">OnInit</span> <span class="p">{</span>
   <span class="nf">ngOnInit</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// The following stream will produce values every second</span>
        <span class="c1">// 0--1--2--3--4--5--6--...</span>
        <span class="kd">const</span> <span class="nx">interval$</span> <span class="o">=</span> <span class="nf">interval</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
        <span class="c1">// Even when this component gets destroyed,</span>
        <span class="c1">// the stream will keep producing values...</span>
        <span class="c1">// This means the console will keep on logging</span>
        <span class="c1">// This is a classic example of a memory-leak</span>
        <span class="kd">const</span> <span class="nx">subscription</span> <span class="o">=</span> <span class="nx">interval$</span><span class="p">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nx">r</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">r</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To remove the memory-leak in this component we can keep track of the subscriptions by taking advantage of the <code class="language-plaintext highlighter-rouge">ngOnDestroy()</code> lifecycle hook of Angular:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">AppComponent</span> <span class="k">implements</span> <span class="nx">OnInit</span><span class="p">,</span> <span class="nx">OnDestroy</span> <span class="p">{</span>
    <span class="nx">subscriptions</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="nf">ngOnInit</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">interval$</span> <span class="o">=</span> <span class="nf">interval</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">subscription</span> <span class="o">=</span> <span class="nx">interval$</span><span class="p">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nx">r</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">r</span><span class="p">));</span>
        <span class="c1">// manually keep track of the subscriptions in a subscription array</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">subscription</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nf">ngOnDestroy</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// when the component get's destroyed, unsubscribe all the subscriptions</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="nx">sub</span> <span class="o">=&gt;</span> <span class="nx">sub</span><span class="p">.</span><span class="nf">unsubscribe</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>However, when we are using a bunch of subscriptions, it can become quite dirty. Before, we talked about the fact that a subscription will live until we manually unsubscribe (like we just did in the snippet above), but also until the stream gets <strong>completed</strong>. A cool way to handle this issue is to use a Subject that we next in the <code class="language-plaintext highlighter-rouge">ngOnDestroy()</code> lifecycle hook of Angular:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">AppComponent</span> <span class="k">implements</span> <span class="nx">OnInit</span><span class="p">,</span> <span class="nx">OnDestroy</span> <span class="p">{</span>
    <span class="nx">destroy$</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Subject</span><span class="p">();</span>
    <span class="nf">ngOnInit</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// interval$: 0--1--2--3--4--5--6--...</span>
        <span class="c1">// destroy$:  -------------true|</span>
        <span class="c1">// result:    0--1--2--3--4|</span>
        <span class="kd">const</span> <span class="nx">interval$</span> <span class="o">=</span> <span class="nf">interval</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
        <span class="nx">interval$</span>
            <span class="c1">// let the interval$ stream live </span>
            <span class="c1">// until the destroy$ Subject gets a value</span>
            <span class="p">.</span><span class="nf">pipe</span><span class="p">(</span><span class="nf">takeUntil</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">destroy$</span><span class="p">))</span>
            <span class="p">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nx">r</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">r</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nf">ngOnDestroy</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// when the component get's destroyed, pass something to the</span>
        <span class="c1">// destroy$ Subject</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">destroy$</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="avoiding-nested-subscribes">Avoiding nested subscribes</h2>

<p>Nesting subscribes is something that needs to be avoided as much as possible. It makes the code unreadable, complex, and introduces side effects.
It basically forces you to <strong>NOT</strong> think reactively. Take this Angular example for instance:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">AppComponent</span> <span class="p">{</span>
    <span class="nl">user</span><span class="p">:</span> <span class="nx">User</span><span class="p">;</span>
    <span class="nf">constructor</span><span class="p">(</span>
        <span class="k">private</span> <span class="nx">route</span><span class="p">:</span> <span class="nx">ActivatedRoute</span><span class="p">,</span> 
        <span class="k">private</span> <span class="nx">userService</span><span class="p">:</span> <span class="nx">UserService</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// when the params of the route changes,</span>
        <span class="c1">// we want to fetch the user and set the user property</span>
        <span class="c1">//</span>
        <span class="c1">// VERY BAD: nesting subscribes is ugly and takes away</span>
        <span class="c1">// the control over a stream</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">route</span><span class="p">.</span><span class="nx">params</span>
            <span class="p">.</span><span class="nf">pipe</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">id</span><span class="p">))</span>
            <span class="p">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nx">id</span> <span class="o">=&gt;</span> 
                <span class="k">this</span><span class="p">.</span><span class="nx">userService</span><span class="p">.</span><span class="nf">fetchById</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
                    <span class="p">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nx">user</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">user</span> <span class="o">=</span> <span class="nx">user</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The previous implementation is considered a bad-practice. It‚Äôs recommended to use <strong>higher-order streams</strong> like <code class="language-plaintext highlighter-rouge">mergeMap</code> or <code class="language-plaintext highlighter-rouge">switchMap</code>. Let‚Äôs have a look at this example:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">AppComponent</span> <span class="p">{</span>
    <span class="nl">user</span><span class="p">:</span> <span class="nx">User</span><span class="p">;</span>
    <span class="nf">constructor</span><span class="p">(</span>
        <span class="k">private</span> <span class="nx">route</span><span class="p">:</span> <span class="nx">ActivatedRoute</span><span class="p">,</span> 
        <span class="k">private</span> <span class="nx">userService</span><span class="p">:</span> <span class="nx">UserService</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="c1">// when the params of the route changes,</span>
        <span class="c1">// we want to fetch the user and set the user property</span>
        <span class="c1">//</span>
        <span class="c1">// GOOD: we have created a single subscribe which makes</span>
        <span class="c1">// the flow way easier and gives us the control we need</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">route</span><span class="p">.</span><span class="nx">params</span>
            <span class="p">.</span><span class="nf">pipe</span><span class="p">(</span>
                <span class="nf">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">id</span><span class="p">),</span>
                <span class="nf">switchMap</span><span class="p">(</span><span class="nx">id</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">userService</span><span class="p">.</span><span class="nf">fetchById</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="p">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nx">user</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">user</span> <span class="o">=</span> <span class="nx">user</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="avoiding-manual-subscribes-in-angular">Avoiding manual subscribes in Angular</h2>

<p>To consume a stream we need to subscribe that stream, that‚Äôs simply how observables work. But what if a component needs values from 5 different streams‚Ä¶ Would that mean, that we want to subscribe to all of these streams and manually map all the values to unique properties, just to make it work? That would suck, right?!</p>

<p>Angular has this super cool feature called the <code class="language-plaintext highlighter-rouge">async pipe</code>. It‚Äôs used to consume streams directly in the template
The async pipe does 3 things for us:</p>
<ul>
  <li>It subscribes to the stream and passes the value to a component</li>
  <li>It <strong>unsubscribes automatically</strong> when the component gets destroyed (removes a lot of unsubscribe logic)</li>
  <li>Triggers change detection automatically</li>
</ul>

<p>This means we don‚Äôt have to manually subscribe nor unsubscribe anymore. Which cleans up the code a lot.
Let‚Äôs have a look at the cleaned up previous example:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
    <span class="p">...</span>
    <span class="na">template</span><span class="p">:</span> <span class="s2">`
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `</span>
<span class="p">})</span>
<span class="kd">class</span> <span class="nc">AppComponent</span> <span class="p">{</span>
    <span class="c1">// expose a user$ stream that will be </span>
    <span class="c1">// subscribed in the template with the async pipe</span>
    <span class="nx">user$</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">route</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nf">pipe</span><span class="p">(</span>
        <span class="nf">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">id</span><span class="p">),</span>
        <span class="nf">switchMap</span><span class="p">(</span><span class="nx">id</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">userService</span><span class="p">.</span><span class="nf">fetchById</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span>
    <span class="p">);</span>

    <span class="nf">constructor</span><span class="p">(</span>
        <span class="k">private</span> <span class="nx">route</span><span class="p">:</span> <span class="nx">ActivatedRoute</span><span class="p">,</span> 
        <span class="k">private</span> <span class="nx">userService</span><span class="p">:</span> <span class="nx">UserService</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If you are into <a href="https://reactjs.org/">React</a>, I‚Äôve created this lib called <a href="https://www.npmjs.com/package/react-rx-connect">react-rx-connect</a> that would solve this problem. It binds the streams to the state, and unsubscribes from them when the component gets destroyed.</p>

<h2 id="dont-pass-streams-to-components-directly">Don‚Äôt pass streams to components directly</h2>

<p>One of the most important aspects of software architecture might be the concept of <strong>decoupling</strong> pieces of code.
Therefore we could consider passing streams to child components as a <strong>bad practice</strong> because it creates a very tight link between the parent component and the child component. They are no longer decoupled since subscriptions in the child component might trigger actions in the parent component. We never want the child component to be responsible of initiating data calls right?! That‚Äôs the task of the smart component. See the difference between
<a href="http://blog.brecht.io/components-demystified/#smart-vs-dumb-components">smart and dumb components here</a>.
A component should always receive an object or value and should not even care if that object or value comes from a stream or not.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// BAD</span>
<span class="c1">// app.component.ts</span>
<span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
    <span class="na">selector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">app</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">template</span><span class="p">:</span> <span class="s2">`
        &lt;!-- 
            BAD: The users$ steram is passed
            to user-detail directly as a stream 
        --&gt;
        &lt;user-detail [user$]="user$"&gt;&lt;/user-detail&gt;
    `</span>
<span class="p">})</span>
<span class="kd">class</span> <span class="nc">AppComponent</span> <span class="p">{</span>
    <span class="c1">// this http call will get called when the </span>
    <span class="c1">// user-detail component subscribes to users$</span>
    <span class="c1">// We don't want that</span>
    <span class="nx">users$</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(...);</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// user-detail.component.ts</span>
<span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
    <span class="na">selector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">user-detail</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">template</span><span class="p">:</span> <span class="s2">`
        
    `</span>
<span class="p">})</span>
<span class="kd">class</span> <span class="nc">UserDetailComponent</span> <span class="k">implements</span> <span class="nx">OnInit</span> <span class="p">{</span>
    <span class="p">@</span><span class="nd">Input</span><span class="p">()</span> <span class="nx">user$</span><span class="p">:</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="nx">User</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="nl">user</span><span class="p">:</span> <span class="nx">User</span><span class="p">;</span>
    <span class="nf">ngOnInit</span><span class="p">(){</span>
        <span class="c1">// WHOOPS! This child component subscribes to the stream</span>
        <span class="c1">// of the parent component which will do an automatic XHR call</span>
        <span class="c1">// because Angular HTTP returns a cold stream</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">user$</span><span class="p">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nx">u</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">user</span> <span class="o">=</span> <span class="nx">u</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It would be better to handle the subscription in the parent component itself:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// GOOD</span>
<span class="c1">// app.component.ts</span>
<span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
    <span class="na">selector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">app</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">template</span><span class="p">:</span> <span class="s2">`
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `</span>
<span class="p">})</span>
<span class="kd">class</span> <span class="nc">AppComponent</span> <span class="k">implements</span> <span class="nx">OnInit</span> <span class="p">{</span>
    <span class="nx">users$</span><span class="p">:</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="nx">User</span><span class="p">[]</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(...);</span>
    <span class="nl">user</span><span class="p">:</span> <span class="nx">User</span><span class="p">;</span>
    <span class="nf">ngOnInit</span><span class="p">(){</span>
        <span class="c1">// the app component (smart) subscribes to the user$ which will</span>
        <span class="c1">// do an XHR call here</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">users$</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(...);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// user-detail.component.ts</span>
<span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
    <span class="na">selector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">user-detail</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">template</span><span class="p">:</span> <span class="s2">`
        
    `</span>
<span class="p">})</span>
<span class="kd">class</span> <span class="nc">UserDetailComponent</span> <span class="p">{</span>
    <span class="c1">// This component doesn't even know that we are using RxJS which</span>
    <span class="c1">// results in better decoupling</span>
    <span class="p">@</span><span class="nd">Input</span><span class="p">()</span> <span class="nx">user</span><span class="p">:</span> <span class="nx">User</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The responsibility of the component is clear. The user-detail is meant to be dumb and is completely decoupled from its parent.</p>

<p>There are however situations where we would like to create a stream from an input. In that case we could take a look at this library: <a href="https://www.npmjs.com/package/ngx-reactivetoolkit">ngx-reactivetoolkit</a></p>

<h2 id="dont-pass-streams-to-services">Don‚Äôt pass streams to services</h2>

<p>Although, it might seem like a pragmatic solution to pass streams directly to services, it could be seen as a <strong>bad practice</strong> if we consider the decoupling again. By passing a stream to a service we don‚Äôt know what‚Äôs going to happen to it. The stream could be subscribed to, or even combined with another stream that has a longer lifecycle, that could eventually determine the state of our application.
Subscriptions might trigger unwanted behavior. And after all, services don‚Äôt care that your components are using streams. Take this example for instance:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// BAD</span>
<span class="c1">// app.component.ts</span>
<span class="kd">class</span> <span class="nc">AppComponent</span> <span class="p">{</span>
     <span class="nx">users$</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(...)</span>
     <span class="nx">filteredusers$</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">fooService</span>
        <span class="p">.</span><span class="nf">filterUsers</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">users$</span><span class="p">);</span> <span class="c1">// Passing stream directly: BAD</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// foo.service.ts</span>
<span class="kd">class</span> <span class="nc">FooService</span> <span class="p">{</span>
    <span class="c1">// return a stream based on a stream</span>
    <span class="c1">// BAD! because we don't know what will happen here</span>
    <span class="nf">filterUsers</span><span class="p">(</span><span class="nx">users$</span><span class="p">:</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="nx">User</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="nx">User</span><span class="p">[]</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">users$</span><span class="p">.</span><span class="nf">pipe</span><span class="p">(</span>
            <span class="nf">map</span><span class="p">(</span><span class="nx">users</span> <span class="o">=&gt;</span> <span class="nx">users</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">user</span> <span class="o">=&gt;</span> <span class="nx">user</span><span class="p">.</span><span class="nx">age</span> <span class="o">&gt;=</span> <span class="mi">18</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It would be better to use higher order streams for these situations.
Use <code class="language-plaintext highlighter-rouge">switchMap</code> over <code class="language-plaintext highlighter-rouge">mergeMap</code> if possible, since it will unsubscribe the previous stream.
The following example is better since all the RxJS logic is centralized in one place where the subscribing and unsubscribing happens: The smart component.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// GOOD</span>
<span class="c1">// app.component.ts</span>
<span class="kd">class</span> <span class="nc">AppComponent</span> <span class="p">{</span>
    <span class="nx">users$</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(...)</span>
    <span class="nx">filteredusers$</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">users$</span>
        <span class="p">.</span><span class="nf">pipe</span><span class="p">(</span><span class="nf">switchMap</span><span class="p">(</span><span class="nx">users</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">fooService</span><span class="p">.</span><span class="nf">filterUsers</span><span class="p">(</span><span class="nx">users</span><span class="p">)));</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// foo.service.ts</span>
<span class="kd">class</span> <span class="nc">FooService</span> <span class="p">{</span>
    <span class="c1">// this is way cleaner: this service doesn't even know</span>
    <span class="c1">// about streams now</span>
    <span class="nf">filterUsers</span><span class="p">(</span><span class="nx">users</span><span class="p">:</span> <span class="nx">User</span><span class="p">[]):</span> <span class="nx">User</span><span class="p">[]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">users</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">user</span> <span class="o">=&gt;</span> <span class="nx">user</span><span class="p">.</span><span class="nx">age</span> <span class="o">&gt;=</span> <span class="mi">18</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="sharing-subscriptions">Sharing subscriptions</h2>

<p>Since most streams are cold by default, every subscription will trigger the <strong>producer</strong> of these streams.
The execution of the producer logic on every subscription, might not be what we want if we have multiple subscriptions.
Eg. Subscribing to Angular its <code class="language-plaintext highlighter-rouge">http.get()</code> multiple times will actually perform multiple xhr calls.
The following example will trigger the xhr call twice because <code class="language-plaintext highlighter-rouge">numberOfUsers$</code> depends on <code class="language-plaintext highlighter-rouge">users$</code>.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
    <span class="na">selector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">app</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">template</span><span class="p">:</span> <span class="s2">`
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `</span>
<span class="p">})</span>
<span class="c1">// BAD</span>
<span class="kd">class</span> <span class="nc">AppComponent</span> <span class="p">{</span>
    <span class="nx">users$</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(...)</span>
    <span class="c1">// the subscription on this stream will execute the xhr call again</span>
    <span class="nx">numberOfUsers$</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">users$</span><span class="p">.</span><span class="nf">pipe</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>In those cases we might want to share the subscriptions. The following example uses the <code class="language-plaintext highlighter-rouge">share()</code> operator:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
    <span class="na">selector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">app</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">template</span><span class="p">:</span> <span class="s2">`
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `</span>
<span class="p">})</span>
<span class="c1">// GOOD</span>
<span class="kd">class</span> <span class="nc">AppComponent</span> <span class="p">{</span>
    <span class="nx">users$</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(...).</span><span class="nf">pipe</span><span class="p">(</span><span class="nf">share</span><span class="p">());</span>
    <span class="c1">// the subscription on this stream will execute the xhr call again</span>
    <span class="nx">numberOfUsers$</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">users$</span><span class="p">.</span><span class="nf">pipe</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>Sharing a stream makes it hot. This means that if we subscribe after the value is produced, we will miss that value.
In that case we might want to use <code class="language-plaintext highlighter-rouge">shareReplay(1)</code> instead of <code class="language-plaintext highlighter-rouge">share()</code>. This will keep the last value in memory for us.</p>

<p>It‚Äôs a common mistake to share everything. We don‚Äôt always want to work with hot streams and sharing subscriptions comes with a small performance cost.Also, lazy streams have their advantages.</p>

<p>Angular also provides a <em>great alternative</em> that can reduce the sharing of streams to a minimum by using the <code class="language-plaintext highlighter-rouge">async as else</code> syntax.. 
Personally I would consider the use of this feature as a best practice.
The following example reduces the number of streams, the number of subscriptions and gives us <strong>an easy way to show a loading indicator</strong>.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
    <span class="na">selector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">app</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">template</span><span class="p">:</span> <span class="s2">`
        &lt;div *ngIf="users$|async as users; else loading"&gt;
            Number of users: 
            &lt;users-grid [users]="users"&gt;&lt;/users-grid&gt;
        &lt;/div&gt;
        &lt;ng-template #loading&gt;Loading...&lt;/ng-template&gt;
    `</span>
<span class="p">})</span>
<span class="kd">class</span> <span class="nc">AppComponent</span> <span class="p">{</span>
    <span class="c1">// This stream will only subscribed to once</span>
    <span class="nx">users$</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(...);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="when-to-use-subjects">When to use Subjects</h2>

<p>A Subject is both a hot observable and an observer at the same time. This gives us the opportunity to next values into the stream ourselves.
Subjects tend to be overused by people that didn‚Äôt make the mind switch towards reactive programming yet.</p>

<p>Only use them when really needed, for instance it‚Äôs ok to use Subjects in the following scenarios:</p>
<h4 id="when-mocking-streams-in-tests">When mocking streams in tests</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fetchAll$</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Subject</span><span class="p">();</span> <span class="c1">// use a Subject as a mock</span>
<span class="nx">usersServiceMock</span><span class="p">.</span><span class="nx">fetchAll</span><span class="p">.</span><span class="nf">mockReturnValue</span><span class="p">(</span><span class="nx">fetchAll$</span><span class="p">);</span>
<span class="nx">fetchAll$</span><span class="p">.</span><span class="nf">next</span><span class="p">(</span><span class="nx">fakeUser</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="when-we-want-to-create-streams-from-outputs-in-angular">When we want to create streams from outputs in Angular</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">Component</span><span class="p">({</span>
    <span class="p">...</span>
    <span class="na">template</span><span class="p">:</span> <span class="s2">`
    &lt;some-component (search)="search$.next($event)"&gt;&lt;/some-component&gt;
    `</span>
<span class="p">})</span>
<span class="kd">class</span> <span class="nc">AppComponent</span> <span class="p">{</span>
<span class="nx">search$</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Subject</span><span class="p">();</span> <span class="c1">// ----t-----te-----ter----term...</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="when-handling-circular-references">When handling circular references</h4>

<p>I‚Äôm not going to dive in this to deep, but <a href="">Dominic Elm</a> does an awesome job explaining this in <a href="https://blog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html#behaviorsubject-to-the-rescue">this great article</a></p>

<p>For most other cases an operator or Observable.create might be enough.</p>

<p><strong>Note:</strong>
A BehaviorSubject is commonly used because it has a <code class="language-plaintext highlighter-rouge">getValue()</code> function. That would also be considered a bad practice.
When we are trying to fetch a specific value it usually means we are not thinking reactive.</p>

<h2 id="clean-code-practices">Clean code practices</h2>
<p>Consistent code indentation and formatting can improve the readability of complex streams:</p>
<ul>
  <li>Align operators below each other</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">foo$</span><span class="p">.</span><span class="nf">pipe</span><span class="p">(</span>
        <span class="nf">map</span><span class="p">(...)</span>
        <span class="nf">filter</span><span class="p">(...)</span>
        <span class="nf">tap</span><span class="p">(...)</span>
    <span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Extract into different streams when it becomes unreadable</li>
  <li>Put complexer functionality in private methods (make the reactive flow clear)</li>
  <li>Avoid the use of brackets for readability, that‚Äôs personal preference.</li>
</ul>

<h2 id="angular-embraces-rxjs">Angular embraces RxJS</h2>

<p>We already saw a glimpse of why Angular is a framework that really embraces the use of RxJS.
Therefore it‚Äôs recommended to use the functionality that Angular provides.</p>
<ul>
  <li>The <code class="language-plaintext highlighter-rouge">ActivatedRoute</code> has exposes a params stream.</li>
  <li>The Http and HttpClient both return streams</li>
  <li>The <code class="language-plaintext highlighter-rouge">Form</code> and <code class="language-plaintext highlighter-rouge">FormControl</code> both have a <code class="language-plaintext highlighter-rouge">valueChanges</code> property that returns a stream</li>
  <li>The async pipe is an awesome feature that really helps us to use the streams in our templates</li>
  <li>Using the <code class="language-plaintext highlighter-rouge">ngOnInit()</code> lifecycle function to initialize streams can help us for mocking purposes</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Still here? Awesome! We learned a lot! If this article interests you, you might want to check out the ‚ÄúAdvanced RxJS in Angular workshop‚Äù from <a href="https://strongbrew.io">Strongbrew</a>, where me and <a href="blog.kwintenp.com">Kwinten Pisman</a> teach how to use advanced RxJS in real Angular applications.</p>
:ET