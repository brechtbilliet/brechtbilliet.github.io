I"iW<p><a href="https://angular.io/">Angular 2</a> and <a href="https://github.com/reactjs/redux">redux</a> are 2 technologies that are getting a lot of traction these days. Angular 2 is a SPA (single-page-app) framework and redux is a state management tool. Most developers that are using Angular 2 are using the <a href="https://github.com/ngrx/store">@ngrx/store</a> variant of the redux principle. Because I’m one of them I will be using @ngrx/store instead of redux.js for this article. Don’t let that bother you, what you are about to read can be used with redux.js in the exact same way. If you have never heard about redux, I strongly advice to read the <a href="http://redux.js.org/">documentation</a> first.</p>

<h2 id="optimistic-updates">Optimistic updates</h2>

<p>Redux has a client-side store that has all the data and state your client-side application needs. Therefore, it is the single source of truth for your frontend. When something in that store changes, your components get updated automatically. Let’s say that we are implementing a winecellar application which will obviously contain an array of wines.</p>

<p><strong>Scenario: we want to remove a wine from the winecellar.</strong></p>

<p>A user goes to the index page of our application, clicks a delete button in the datagrid which will call an angular service to remove a wine. The service does an HTTP call to a server, and when the wine finally gets deleted, the service responds with a 200 response (ok). When that happens we can update the redux store and our view gets updated.
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/optimisticupdates/optimisticupdates_scenario1.png" alt="Scenario 1" /></p>

<p>The code explained above might look like this:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">remove</span><span class="p">(</span><span class="nx">wine</span><span class="p">:</span> <span class="nx">Wine</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">http</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">API_URL</span><span class="p">}</span><span class="s2">/wines/</span><span class="p">${</span><span class="nx">wine</span><span class="p">.</span><span class="nx">_id</span><span class="p">}</span><span class="s2">`</span><span class="p">).</span><span class="nx">subscribe</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    	<span class="c1">// dispatch the action to the store, when the call was successful</span>
    	<span class="k">this</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="nx">REMOVE_WINE</span><span class="p">,</span> <span class="na">payload</span><span class="p">:</span> <span class="p">{</span><span class="na">_id</span><span class="p">:</span> <span class="nx">wine</span><span class="p">.</span><span class="nx">_id</span><span class="p">}});</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is the traditional way of doing things, but I think we can do it better. What if we would update the store, regardless of the HTTP response the server returns? We click the delete button in the datagrid, call the angular service like we already did. But in that service we update the store directly (parallel with the http call)</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/optimisticupdates/optimisticupdates_scenario2.png" alt="Scenario 2" /></p>

<p>The code explained above might look like this:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">remove</span><span class="p">(</span><span class="nx">wine</span><span class="p">:</span> <span class="nx">Wine</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
	<span class="c1">// dispatch directly to the store</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="nx">REMOVE_WINE</span><span class="p">,</span> <span class="na">payload</span><span class="p">:</span> <span class="p">{</span><span class="na">_id</span><span class="p">:</span> <span class="nx">wine</span><span class="p">.</span><span class="nx">_id</span><span class="p">}};</span>
	<span class="c1">// we still have to subscribe because http calls return cold observables</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">http</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">API_URL</span><span class="p">}</span><span class="s2">/wines/</span><span class="p">${</span><span class="nx">wine</span><span class="p">.</span><span class="nx">_id</span><span class="p">}</span><span class="s2">`</span><span class="p">).</span><span class="nx">subscribe</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is a pretty nice change: Our application has just gotten a lot <strong>faster and snappier</strong>. Every time the user does an action, the store gets updated immediately, which means that the components will get updated immediately as well. We never have to wait for http responses again.</p>

<p>There is one exception to this rule: When <strong>adding</strong> data, the backend has to return an ID which means that for POST calls we will have to postpone the store update until we get a 200 response. (otherwise we would have id-less wines in our store, and we can’t have that)</p>

<h2 id="what-if-the-server-call-fails">What if the server-call fails?</h2>

<p>What if the user’s internet-connection is lost? Or the backend doesn’t return a 200 response but an error. Our store will already be updated, the wine will be lost when it’s in fact still in the database. In some scenarios you want to prevent that kind of behavior. In those cases we want to rollback that specific action, but not interfere with the rest of the actions. It has to be completely safe.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/optimisticupdates/optimisticupdates_scenario3.png" alt="Scenario 3" /></p>

<p>We would like to implement something like this:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">remove</span><span class="p">(</span><span class="nx">wine</span><span class="p">:</span> <span class="nx">Wine</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
	<span class="c1">// create an action</span>
	<span class="kd">let</span> <span class="nx">action</span> <span class="o">=</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="nx">REMOVE_WINE</span><span class="p">,</span> <span class="na">payload</span><span class="p">:</span> <span class="p">{</span><span class="na">_id</span><span class="p">:</span> <span class="nx">wine</span><span class="p">.</span><span class="nx">_id</span><span class="p">}};</span>
	<span class="c1">//dispatch the action to the store</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="nx">action</span><span class="p">);</span>
	<span class="c1">// call the backend</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">http</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">API_URL</span><span class="p">}</span><span class="s2">/wines/</span><span class="p">${</span><span class="nx">wine</span><span class="p">.</span><span class="nx">_id</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
    	<span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span>
    		<span class="c1">// on success, do nothing</span>
    		<span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{},</span> 
	    	<span class="c1">// on error, rollback the action</span>
	    	<span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
	    		<span class="k">this</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">UNDO_ACTION</span><span class="dl">"</span><span class="p">,</span> <span class="na">payload</span><span class="p">:</span> <span class="nx">action</span><span class="p">});</span>
	    	<span class="c1">// maybe show somekind of errormessage to show the user that it's action failed</span>
    	<span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It turns out that when using the redux pattern, this only takes 12 lines of code (without comments :-)). We will have to create a parent reducer that will delegate to our root reducer. The parent reducer will keep track of all the actions, so they can be rolled back.
The implementation looks like this:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span><span class="nx">ApplicationState</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../statemanagement/state/ApplicationState</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">Action</span><span class="p">,</span> <span class="nx">ActionReducer</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@ngrx/store</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">function</span> <span class="nx">handleUndo</span><span class="p">(</span><span class="nx">rootReducer</span><span class="p">:</span> <span class="nx">ActionReducer</span><span class="o">&lt;</span><span class="nx">ApplicationState</span><span class="o">&gt;</span><span class="p">)</span>
	<span class="p">:</span> <span class="nx">ActionReducer</span><span class="o">&lt;</span><span class="nx">ApplicationState</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="c1">// keep the executedActions</span>
    <span class="kd">let</span> <span class="na">executedActions</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Action</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">return</span> <span class="p">(</span><span class="na">state</span><span class="p">:</span> <span class="nx">ApplicationState</span><span class="p">,</span> <span class="na">action</span><span class="p">:</span> <span class="nx">Action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">UNDO_ACTION</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        	<span class="c1">// if the action is UNDO_ACTION, </span>
        	<span class="c1">// then call all the actions again on the rootReducer, </span>
        	<span class="c1">// except the one we want to rollback</span>
            <span class="kd">let</span> <span class="na">newState</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="nx">executedActions</span> <span class="o">=</span> <span class="nx">executedActions</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">eAct</span> <span class="o">=&gt;</span> <span class="nx">eAct</span> <span class="o">!==</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">);</span>
            <span class="c1">// update the state for every action untill we get the</span>
            <span class="c1">// exact same state as before, but without the action we want to rollback</span>
            <span class="nx">executedActions</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">executedAction</span> <span class="o">=&gt;</span> 
            	<span class="nx">newState</span> <span class="o">=</span> <span class="nx">rootReducer</span><span class="p">(</span><span class="nx">newState</span><span class="p">,</span> <span class="nx">executedAction</span><span class="p">));</span>
            <span class="k">return</span> <span class="nx">newState</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// push every action that isn't an UNDO_ACTION to the executedActions property</span>
        <span class="nx">executedActions</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">action</span><span class="p">);</span>
        <span class="c1">// just delegate</span>
        <span class="k">return</span> <span class="nx">rootReducer</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So basically, when an action is being rolled back, every action that has been taken before is being executed on a piece of state again. When that piece of state is updated, it will return it and the store will be updated with the same state, except the one that our rolled back action created.</p>

<p>To make sure the actions can be undone, we have to make redux use the piece of code above. This is how you could use it in Angular 2.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">NgModule</span><span class="p">({</span>
	<span class="c1">// instead of passing the rootReducer directly</span>
	<span class="c1">// like we would have done before, wrap it in the handleUndo function</span>
    <span class="na">imports</span><span class="p">:</span> <span class="p">[</span><span class="nx">StoreModule</span><span class="p">.</span><span class="nx">provideStore</span><span class="p">(</span><span class="nx">handleUndo</span><span class="p">(</span><span class="nx">rootReducer</span><span class="p">))</span><span class="cm">/*, ...*/</span><span class="p">],</span>
    <span class="cm">/* ... */</span>
<span class="p">})</span>
<span class="k">export</span> <span class="kd">class</span> <span class="nx">AppModule</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="possible-improvements">Possible improvements</h2>

<p>Won’t it become slow after a while, replaying all these actions?
Some facts:</p>
<ul>
<li>Actions are very cheap</li>
<li>They will update the store only once, we execute the actions ourselves, so ui won't get updated</li>
<li>Actions only get replayed when there is an error</li>
<li>The devtools also work like that, enables [timetraveling](https://onsen.io/blog/react-redux-devtools-with-time-travel)</li>
</ul>
<p>What if it would become slow?
We can implement a buffer. Let’s say that we only want the last 100 actions to be kept.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">function</span> <span class="nx">handleUndo</span><span class="p">(</span><span class="nx">rootReducer</span><span class="p">:</span> <span class="nx">ActionReducer</span><span class="o">&lt;</span><span class="nx">ApplicationState</span><span class="o">&gt;</span><span class="p">,</span> 
	<span class="nx">bufferSize</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span> <span class="nx">ActionReducer</span><span class="o">&lt;</span><span class="nx">ApplicationState</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="na">executedActions</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Action</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">initialState</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="na">state</span><span class="p">:</span> <span class="nx">ApplicationState</span><span class="p">,</span> <span class="na">action</span><span class="p">:</span> <span class="nx">Action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">UNDO_ACTION</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        	<span class="c1">// if the action is UNDO_ACTION, </span>
        	<span class="c1">// then call all the actions again on the rootReducer, </span>
        	<span class="c1">// except the one we want to rollback</span>
            <span class="kd">let</span> <span class="na">newState</span><span class="p">:</span> <span class="kr">any</span> <span class="o">=</span> <span class="nx">initialState</span><span class="p">;</span>
            <span class="nx">executedActions</span> <span class="o">=</span> <span class="nx">executedActions</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">eAct</span> <span class="o">=&gt;</span> <span class="nx">eAct</span> <span class="o">!==</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">);</span>
            <span class="c1">// update the state for every action untill we get the</span>
            <span class="c1">// exact same state as before, but without the action we want to rollback</span>
            <span class="nx">executedActions</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">executedAction</span> <span class="o">=&gt;</span> 
            	<span class="nx">newState</span> <span class="o">=</span> <span class="nx">rootReducer</span><span class="p">(</span><span class="nx">newState</span><span class="p">,</span> <span class="nx">executedAction</span><span class="p">));</span>
            <span class="k">return</span> <span class="nx">newState</span><span class="p">;</span>
        <span class="p">}</span>
       	<span class="c1">// push every action that isn't an UNDO_ACTION to the executedActions property</span>
		<span class="nx">executedActions</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">action</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">updatedState</span> <span class="o">=</span>  <span class="nx">rootReducer</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">executedActions</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">bufferSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">firstAction</span> <span class="o">=</span> <span class="nx">executedActions</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="c1">// calculate the state x (buffersize) actions ago</span>
            <span class="nx">initialState</span> <span class="o">=</span> <span class="nx">rootReducer</span><span class="p">(</span><span class="nx">initialState</span><span class="p">,</span> <span class="nx">firstAction</span><span class="p">);</span>
            <span class="c1">// keep the correct actions</span>
            <span class="nx">executedActions</span> <span class="o">=</span> <span class="nx">executedActions</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">bufferSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">updatedState</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="conclusion">Conclusion</h3>
<p>The redux pattern has opened amazing doors for frontend development. Just like <a href="http://blog.brecht.io/How-we-made-our-app-real-time-in-6-lines-of-code/">realtime</a> became a breeze we can do optimistic updates with almost no effort.
The reason why you would do optimistic updates is that your application becomes amazingly fast and snappy! When implementing optimistic updates, the user will experience a native, mobile feeling.</p>

<p>Here you can find the npm package I’ve created for angular, called <a href="https://www.npmjs.com/package/ngrx-undo">ngrx-undo</a></p>

<p>Let me know if you enjoyed this article!</p>
:ET